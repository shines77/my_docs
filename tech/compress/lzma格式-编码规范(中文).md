# LZMA 规范（草案版本）

## 概述

- 作者：Igor Pavlov
- 日期：2015-06-14

本规范定义了 LZMA 压缩数据的格式以及 lzma 文件格式。

## 符号说明

我们使用 C++ 编程语言的语法。

在 C++ 代码中使用以下类型：

- `unsigned` - 无符号整数，至少 16 位
- `int` - 有符号整数，至少 16 位
- `UInt64` - 64 位无符号整数
- `UInt32` - 32 位无符号整数
- `UInt16` - 16 位无符号整数
- `Byte` - 8 位无符号整数
- `bool` - 布尔类型，取值为 `false` 或 `true`

---

## lzma 文件格式

lzma 文件包含原始的 LZMA 数据流以及相关的属性头。
此类文件使用 ".lzma" 扩展名。

### lzma 文件格式布局：

| 偏移量 | 大小 | 描述 |
|--------|------|------|
| 0      | 1    | LZMA 模型属性（lc、lp、pb）的编码形式 |
| 1      | 4    | 字典大小（32 位无符号整数，小端序） |
| 5      | 8    | 未压缩数据大小（64 位无符号整数，小端序） |
| 13     |      | 压缩数据（LZMA 流） |

### LZMA 属性：

| 名称      | 范围           | 描述 |
|-----------|----------------|------|
| lc        | [0, 8]         | "字面上下文"位数 |
| lp        | [0, 4]         | "字面位置"位数 |
| pb        | [0, 4]         | "位置"位数 |
| dictSize  | [0, 2^32 - 1]  | 字典大小 |

以下代码用于编码 LZMA 属性：

```cpp
void EncodeProperties(Byte *properties) {
  properties[0] = (Byte)((pb * 5 + lp) * 9 + lc);
  Set_UInt32_LittleEndian(properties + 1, dictSize);
}
```

如果属性中的字典大小值小于 `(1 << 12)`，LZMA 解码器必须将字典大小变量设置为 `(1 << 12)`。

```cpp
#define LZMA_DIC_MIN (1 << 12)

unsigned lc, pb, lp;
UInt32 dictSize;
UInt32 dictSizeInProperties;

void DecodeProperties(const Byte *properties) {
  unsigned d = properties[0];
  if (d >= (9 * 5 * 5))
    throw "Incorrect LZMA properties";
  lc = d % 9;
  d /= 9;
  pb = d / 5;
  lp = d % 5;
  dictSizeInProperties = 0;
  for (int i = 0; i < 4; i++)
    dictSizeInProperties |= (UInt32)properties[i + 1] << (8 * i);
  dictSize = dictSizeInProperties;
  if (dictSize < LZMA_DIC_MIN)
    dictSize = LZMA_DIC_MIN;
}
```

如果 "未压缩大小" 字段的所有 64 位均为 1，则表示未压缩大小未知，并且数据流中存在 "结束标记"，用于指示解码结束点。
反之，如果 "未压缩大小" 字段的值不等于 `(2^64 - 1)`，则必须在解码指定数量的字节（未压缩大小）后完成 LZMA 流的解码。如果存在 "结束标记"，LZMA 解码器也必须读取该标记。

---

## 编码 LZMA 属性的新方案

如果 LZMA 压缩用于其他格式，建议使用新的改进方案来编码 LZMA 属性。该新方案已在 xz 格式中使用，该格式采用基于 LZMA 算法的 LZMA2 压缩算法。

LZMA2 中的字典大小仅用一个字节编码，并且 LZMA2 仅支持一组简化的字典大小：

`(2 << 11)`、`(3 << 11)`、`(2 << 12)`、`(3 << 12)`、...、
`(2 << 30)`、`(3 << 30)`、`(2 << 31) - 1`

可以通过以下代码从编码值中提取字典大小：

```cpp
dictSize = (p == 40) ? 0xFFFFFFFF : (((UInt32)2 | ((p) & 1)) << ((p) / 2 + 11));
```

此外，LZMA2 对 "lc" 和 "lp" 属性有额外限制（`lc + lp <= 4`）：

```cpp
if (lc + lp > 4)
  throw "Unsupported properties: (lc + lp) > 4";
```

这种限制对 LZMA 解码器有一些优势：

它减少了解码器分配的表的最大大小，并降低了初始化过程的复杂性，这对于保持大量小型 LZMA 流的高速解码非常重要。

建议在任何使用 LZMA 压缩的新格式中采用此限制（`lc + lp <= 4`）。注意，仅在某些罕见情况下，"lc" 和 "lp" 参数的组合（`lc + lp > 4`）才能显著提高压缩比。

在新方案中，LZMA 属性可以编码为两个字节：

| 偏移量 | 大小 | 描述 |
|--------|------|------|
| 0      | 1    | 使用 LZMA2 方案编码的字典大小 |
| 1      | 1    | LZMA 模型属性（lc、lp、pb）的编码形式 |

---

## 内存使用情况

LZMA 解码器的内存使用情况由以下部分组成：

1) 滑动窗口（从 4 KiB 到 4 GiB）。
2) 概率模型计数器数组（16 位变量的数组）。
3) 一些额外的状态变量（约 10 个 32 位整数变量）。

### 滑动窗口的内存使用情况

解码有两种主要场景：

1) 将完整流解码到一个内存缓冲区。
2) 解码到外部存储。

如果解码到外部存储，解码器必须为滑动窗口分配缓冲区，其大小必须大于或等于 LZMA 流属性中的字典大小值。

### 概率模型计数器的内存使用情况

概率模型计数器数组的大小通过以下公式计算：

`size_of_prob_arrays = 1846 + 768 * (1 << (lp + lc))`

每个概率模型计数器是一个 11 位无符号整数。如果使用 16 位整数变量（2 字节整数）存储这些计数器，则内存使用量可通过以下公式估算：

`RAM = 4 KiB + 1.5 KiB * (1 << (lp + lc))`

例如，对于默认的 LZMA 参数（`lp = 0` 和 `lc = 3`），内存使用量为：

`RAM_lc3_lp0 = 4 KiB + 1.5 KiB * 8 = 16 KiB`

最大内存使用量出现在 `lp = 4` 和 `lc = 8` 时：

`RAM_lc8_lp4 = 4 KiB + 1.5 KiB * 4096 = 6148 KiB`

如果解码器采用 LZMA2 的限制条件（`lc + lp <= 4`），内存使用量不会超过：

`RAM_lc_lp_4 = 4 KiB + 1.5 KiB * 16 = 28 KiB`

### 编码器的内存使用情况

LZMA 编码器有许多变体，其内存消耗各不相同。注意，LZMA 编码器的内存消耗不能小于相同流的 LZMA 解码器的内存消耗。

现代高效 LZMA 编码器的内存使用量可通过以下公式估算：

`Encoder_RAM_Usage = 4 MiB + 11 * dictionarySize`

但某些编码模式需要较少的内存。

---

## LZMA 解码

LZMA 压缩算法使用基于 LZ 的滑动窗口压缩和范围编码作为熵编码方法。

### 滑动窗口

LZMA 使用类似于 LZ77 算法的滑动窗口压缩。

LZMA 流必须解码为以下序列：

- **字面量（LITERAL）**：8 位字符（1 字节），解码器将其放入未压缩流中。
- **匹配（MATCH）**：一对数字（距离-长度对），解码器从滑动窗口中复制指定距离和长度的字节序列。

### 范围解码器

LZMA 算法使用范围编码作为熵编码方法。

LZMA 流包含一个大端编码的大数字，范围解码器用于从该数字中提取二进制符号序列。

范围解码器的状态包括：

- `Range` 和 `Code` 变量（32 位无符号整数）。
- `Corrupted` 标志，用于检测数据流中的损坏。

范围解码器首先从输入流中读取 5 个字节以初始化状态：

```cpp
bool CRangeDecoder::Init() {
  Corrupted = false;
  Range = 0xFFFFFFFF;
  Code = 0;
  Byte b = InStream->ReadByte();
  for (int i = 0; i < 4; i++)
    Code = (Code << 8) | InStream->ReadByte();
  if (b != 0 || Code == Range)
    Corrupted = true;
  return b == 0;
}
```

LZMA 编码器始终在压缩流的初始字节中写入零。如果初始字节不为零，LZMA 解码器必须停止解码并报告错误。

### 位解码与概率模型

LZMA 使用两种类型的二进制符号进行范围编码：

1) 具有固定和相等概率的直接位。
2) 具有预测概率的二进制符号。

概率模型的任务是估计二进制符号的概率，并将该信息提供给范围解码器。概率值以 11 位无符号整数的形式表示符号 "0" 的概率。

### LZMA 解码模式

LZMA 流有两种类型：

1) 带有 "流结束标记" 的流。
2) 不带有 "流结束标记" 的流。

LZMA 解码器支持三种解码模式：

1) 未定义解压大小，解码器在收到 "流结束标记" 后停止。
2) 解压大小已定义，流可能包含或不包含 "流结束标记"。
3) 解压大小已定义，且流必须包含 "流结束标记"。

### 主解码循环

LZMA 解码器的主循环包括以下步骤：

1) 检查流结束条件。
2) 解码匹配或字面量类型。
3) 如果是字面量，解码并放入滑动窗口。
4) 如果是匹配，解码长度和距离，并复制匹配的字节序列。

LZMA 使用三种匹配类型：

1) **简单匹配**：使用位模型编码的距离值。
2) **重复匹配**：使用距离历史表中的距离。
3) **短重复匹配**：单字节长度的匹配，使用距离历史表中的最新距离。

解码器维护最近使用的 4 个匹配距离的历史记录，并通过状态变量和概率模型选择匹配或字面量类型。

---

## 注意事项

本规范未描述支持部分解码的解码器实现变体。此类实现可能需要对 "流结束" 条件检查代码进行修改，并可能使用额外的状态码。

本规范使用 C++ 代码和模板简化描述。优化的 LZMA 解码器不需要模板，可以使用两个 CProb 变量数组：

1) 动态分配的字面量解码器数组。
2) 包含所有其他 CProb 变量的公共数组。

---

## 参考文献

1. G. N. N. Martin, Range encoding: an algorithm for removing redundancy from a digitized message, Video & Data Recording Conference, Southampton, UK, July 24-27, 1979.
