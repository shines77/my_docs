# C++ 整型常量除法转换为乘法 + 位移的方法

## 引言

在 C++ 编译器，有些时候会遇到整数常量除法的问题，编译器会采用整数乘法加位移的方法来实现，在 C++ 代码中也同样可以这样做。原因是，在大多数 CPU 中，整数除法指令是比较慢的（也包括浮点除法指令），相比整数除法指令，花费的的时钟周期多很多，且时钟周期不是固定值，具体的时钟周期是由被除数的值所决定的，效率非常低。在现代 x86 架构的 CPU 中，整数乘法一般只需要 3 个时钟周期，整数除法则可能需要 10-80 个时钟周期不等。

## 整数除法

设被除数为 $C$，除数为 $d$，

整数除法的式子为：$q = \left\lfloor \frac{C}{d} \right\rfloor, r = C /bmod d$，

其中 $q$ 为 $\frac{C}{d}$ 的商，$r$ 为 $\frac{C}{d}$ 的余数。

## 整型常量除法优化

### 1. 前提条件

首先，要明确一点，我们只能对已知除数 $d$ 是常量的整数除法做优化，如果 $d$ 是变量，那只能老老实实用整数除法指令。

### 2. 优化思路

优化的思路是，把除法变为乘法，我们知道，除法可以等价于乘以除数 $d$ 的倒数，即 $1 / d$，这个倒数是小数，整数运算里不能存在小数，于是我们想办法放大这个倒数。

那么问题来了，放大多少倍呢？这里我们先假设是 32 位的整型常量的除法，首先第一个想到的是放大 2^32 倍，即 $2^32 / d$，乘法完了，最后再缩小 2^32 倍。这样是可以，但是还不够。

我们先从最终的结果来看，假设被除数是 $C$，倒数的乘值为 $d_{inverse}$，位移量位 $d_{shift}$，最终得到的商为 $q$：

$$q = \frac{C /cdot d_{inverse}}{2^d_{shift}}}$$

这里 $C$、$d_{inverse}$ 都是 32 位整型，为了充分利用，我们让 $d_{inverse}$ 值的保持在 $\text{0x80000000} <= d_{inverse} <= \text{0xFFFFFFFF}$ 范围内。

